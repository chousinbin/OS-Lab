# 进程调度算法模拟

本项目实现了几种常见的进程调度算法，包括先来先服务（FCFS）、最短剩余时间优先（SRTF）、轮转调度（RR）和非抢占式优先级调度（PNP）。这些算法被用于操作系统中以决定进程的执行顺序和时间。

## 安装指南

本程序使用标准 C++ 编写，可以在任何支持 C++ 的编译环境中编译和运行。

### 编码格式

GBK

### 环境要求

- 支持 C++11 或更高版本的编译器
- 标准库支持

### 编译方法

使用以下命令来编译程序：

```bash
g++ -std=c++11 scheduler.cpp -o scheduler 
```

### 运行方法

运行编译后的程序后，用户会看到一个菜单，可以选择不同的调度算法进行模拟。

```bash
./scheduler
```

根据屏幕提示输入选项编号以选择不同的算法。每种算法可能需要输入特定的进程信息，如到达时间、工作时间和优先级等。

## 代码结构

### 主要文件

- `scheduler.cpp`：包含主函数和所有调度算法的实现。

### 数据结构

- `Node` 结构体：用于存储每个进程的信息，如 PID、到达时间、工作时间等。

### 关键函数

- `FCFS()`：实现先来先服务调度算法。
- `SRTF()`：实现最短剩余时间优先调度算法。
- `RR()`：实现轮转调度算法。
- `PNP()`：实现非抢占式优先级调度算法。
- `input()` 和 `input_PNP()`：负责输入进程数据。
- `output()`：输出调度结果和甘特图。
- `pause()`：程序暂停等待用户输入，用于步进调试。

## 功能解释

- **先来先服务（FCFS）**：按照进程到达的顺序进行调度。
- **最短剩余时间优先（SRTF）**：总是执行剩余时间最短的进程。
- **轮转调度（RR）**：每个进程被分配一个时间片，循环执行。
- **非抢占式优先级调度（Priority）**：根据进程的优先级进行调度，高优先级的进程先执行。

## 运行效果

### Menu

```
=======主菜单=======
1. FCFS算法
2. SRTF算法(最短剩余优先)
3. RR算法(同时到达)
4. 优先级算法(非抢占)
0. 退出程序
=====================
请输入你的选项:
```

### FIFS

```
PID      到达时间        开始时间        工作时间        结束时间        周转时间
0        1                1                3                4                3
1        2                4                5                9                7
2        4                9                6               15               11
3个进程的平均周转时间为:7

甘特图如下(@为运行, *为等待)
00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 [time]
     @  @  @                                 | pid->0
        *  *  @  @  @  @  @                  | pid->1
              *  *  *  *  *  @  @  @  @  @  @| pid->2
请输入任意键继续
```

### SRTF

```
PID      到达时间        开始时间        工作时间        结束时间        周转时间
0        0                0                6               12               12
1        2                2                4                8                6
2        4                4                2                6                2
3个进程的平均周转时间为:6.66667

甘特图如下(@为运行, *为等待)
00 01 02 03 04 05 06 07 08 09 10 11 12 [time]
  @  @  *  *  *  *  *  *  @  @  @  @| pid->0
        @  @  *  *  @  @            | pid->1
              @  @                  | pid->2
请输入任意键继续
```

### Round-Robin

```
PID      到达时间        开始时间        工作时间        结束时间        周转时间
1        0                0                3                7                7
2        0                2                4                9                9
0        0                4                5               12               12
3个进程的平均周转时间为:9.33333

甘特图如下(@为运行, *为等待)
00 01 02 03 04 05 06 07 08 09 10 11 12 [time]
  @  @  *  *  *  *  @               | pid->1
  *  *  @  @  *  *  *  @  @         | pid->2
  *  *  *  *  @  @  *  *  *  @  @  @| pid->0
请输入任意键继续
```

### Priority

```
PID      到达时间        开始时间        工作时间        结束时间        周转时间
0        0                0                3                3                3
1        1                3                2                5                4
2        2                5                1                6                4
3个进程的平均周转时间为:3.66667

甘特图如下(@为运行, *为等待)
00 01 02 03 04 05 06 [time]
  @  @  @         | pid->0
     *  *  @  @   | pid->1
        *  *  *  @| pid->2
请输入任意键继续
```

# 页面置换算法模拟

这个项目是一个页面替换算法模拟器，用于演示和学习操作系统中的三种常见页面替换策略：先进先出（FIFO）、最近最少使用（LRU）以及第二次机会（Second Chance）算法。

## 安装指南

### 编码格式

GBK

### 环境需求

- 操作系统：Windows（由于使用了`system("cls")`命令，当前代码仅支持Windows环境）。
- 编译器：支持C++11或以上版本的编译器。

### 编译方法

使用任何支持C++的编译器编译此程序。例如，如果您使用g++，可以通过以下命令来编译：

```
g++ -o PageReplacementSimulator replacement.cpp
```

### 运行方法

编译完成后，在命令行中运行编译出的可执行文件：

```
./PageReplacementSimulator
```

按照屏幕指示选择不同的页面替换算法进行模拟，输入内存长度和页面请求序列，程序将展示每一步的详细处理过程。

## 代码结构

### 主要文件

- `PageReplacementSimulator.cpp`：这个文件包含了页面置换算法模拟器的所有逻辑，包括主函数和各种页面置换策略的实现。

### 数据结构

- `Page` 结构体：可能用于存储页面信息，如页面编号和其他相关标志（如访问标志、修改标志等）。
- 链表或数组：用于模拟内存中的页面帧，存储当前加载的页面并按照不同的页面置换算法进行管理。

### 关键函数

- `FIFO()`：实现先进先出页面置换算法。
- `LRU()`：实现最近最少使用页面置换算法。
- `SecondChance()`：实现第二次机会页面置换算法，是FIFO的改进版本。
- `insert()`, `delete()`, `query()`: 这些函数用于管理内存中的页面，包括添加新页面、删除页面或查询页面是否存在。
- `showState()`: 显示当前内存中的页面状态，辅助了解算法的运行过程。
- `pause()`：类似于进程调度模拟器，用于步骤之间的暂停。

## 功能解释

- **FIFO（先进先出）**：最简单的页面替换算法，总是淘汰最早进入内存的页面。
- **LRU（最近最少使用）**：淘汰最长时间未被访问的页面，实现方式是将访问过的页面移到链表尾部。
- **Second Chance（第二次机会）**：改进的FIFO算法，给予已在内存中的页面一次额外的机会（通过标记位）避免被立即替换。

